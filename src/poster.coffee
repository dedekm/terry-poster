window.init = () ->
  canvas = document.createElement('canvas')
  canvas.width = WIDTH
  canvas.height = HEIGHT
  document.body.appendChild(canvas)
  ctx = canvas.getContext("2d")

  strings = $('#input input').map((iput) ->
    this.value
    ).get()

  ctx.font = "25px Arial"
  ctx.fillStyle = "#000000"
  ctx.textAlign="center"

  for s, i in strings
    ctx.fillText(s.split("").join(String.fromCharCode(8202)), WIDTH/2, 40 + i* 25)

  pixelGrid = new PixelGrid(ctx)
  document.body.removeChild(canvas)
  $('#input').remove()

  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera( 60, WIDTH / HEIGHT, 63, 105.5 )
  scene = new THREE.Scene()

  renderer = new THREE.WebGLRenderer(  )
  renderer.setSize( WIDTH * 12, HEIGHT * 12 )
  # document.body.appendChild( renderer.domElement )
  renderer.setClearColor(0x000000)

  grid = new Grid(WIDTH, HEIGHT, DEPTH)
  camera.position.set( WIDTH/2, HEIGHT/2 + 2, 105 )

  class Tube
    constructor: (@x, @y, @z) ->
      @x ?= Math.round(Math.random() * WIDTH)
      @y ?= Math.round(Math.random() * HEIGHT)
      @z ?= 0

      grid.setNode(@x,@y,@z, true)
      @path = [this.actualPosition()]

    actualPosition: () ->
      new THREE.Vector3(@x, @y, @z)

    possible_directions: () ->
      preferable = [
        'right' if pixelGrid.getPixel(@x + 1, @y) > 0,
        'up' if pixelGrid.getPixel(@x,@y + 1) > 0,
        'forward' if pixelGrid.getPixel(@x, @y) > 0,
        'left' if pixelGrid.getPixel(@x - 1,@y) > 0,
        'down' if pixelGrid.getPixel(@x,@y - 1) > 0
        # 'backward' if pixelGrid.getPixel(@x, @y) > 0 and @z >= DEPTH - 1
      ].filter(Boolean)
      preferable = ['forward'] if pixelGrid.getPixel(@x, @y) > 0 && @z < DEPTH - DEPTH/2
      preferable = ['backward'] if pixelGrid.getPixel(@x, @y) == 0 && @z > DEPTH / 3

      directions = [
        'right' unless grid.getNode(@x + 1, @y, @z),
        'up' unless grid.getNode(@x, @y + 1, @z),
        'forward' if not grid.getNode(@x, @y, @z + 1) and ((@z < DEPTH / 2 and pixelGrid.getPixel(@x, @y) == 0) or (pixelGrid.getPixel(@x, @y) > 0)),
        'left' unless grid.getNode(@x - 1, @y, @z),
        'down' unless grid.getNode(@x, @y - 1, @z),
        'backward' unless grid.getNode(@x, @y, @z - 1)
      ].filter(Boolean)

      preferable_directions = (direction for direction in directions when direction in preferable)
      if preferable_directions.length > 0
        preferable_directions
      else
        directions

    move: (direction) ->
      pd = this.possible_directions()
      if pd.length > 0
        direction ?= pd[Math.floor(Math.random()*pd.length)]
        switch direction
          when 'right'
            @x++
          when 'up'
            @y++
          when 'forward'
            @z++
          when 'left'
            @x--
          when 'down'
            @y--
          when 'backward'
            @z--

        grid.setNode(@x,@y,@z, true)
        @path.push(this.actualPosition())
      # else
      #   console.log 'cant move'

    createTube: () ->
      curve = new THREE.SplineCurve3(@path)
      geometry = new THREE.TubeGeometry(
        curve, #path
        @path.length * 3, #segments
        0.45, #radius
        8, #radiusSegments
        false #closed
      )
      # tube = new THREE.Mesh( geometry, MATERIAL )

  # scene.add(grid.helpGrid(pixelGrid.pixels))

  n = 5
  tubes = []
  for x in [0...WIDTH/n]
    for y in [0...HEIGHT/n]
      unless grid.getNode(x* n,y * n,1) == 'full'
        tubes.push new Tube(x * n,y * n,1)

  moves = 25
  for [0..moves]
    for tube in tubes
      tube.move()

  # tubes = [new Tube(55, 55,0)]
  # for [0..20]
  #   tubes[0].move()
  #   console.log 'z = ' + tubes[0].z
  #   console.log String(tubes[0].possible_directions())
  #   console.log '----'

  group = new THREE.Geometry()
  for tube in tubes
    group.merge(tube.createTube())

  bufferGeometry = new THREE.BufferGeometry().fromGeometry( group )
  mesh = new THREE.Mesh( bufferGeometry, MATERIAL )
  scene.add(mesh)

  renderPDF= () ->
    dataURL = renderer.domElement.toDataURL()
    doc = new jsPDF('p', 'mm', 'b1-poster')
    doc.addImage(dataURL, 'PNG', 8, 8, 708, 1008)

    doc.setFont("monospace", "bold")
    doc.setFontSize(8)
    doc.setTextColor(160,160,160)

    s = [ strings.join('') + ' poster',
          # 'Â© Martin Dedek, Graficky design 2, FUD UJEP',
          # "n#{n}/m#{moves}",
          'generated by software licensed under the MIT licence',
          'dedekm.github.io/terry-poster',
          new Date().toUTCString() + ' for Terry posters'
        ]
    for string, i in s
      doc.text("#{new Date().getTime()} ~ #{string}", 22, 1000 - (s.length-1) * 4 + i * 4)

    for i in [{c: 255, w: 1.5}, {c: 0, w: 0.5}]
      doc.setDrawColor(i.c,i.c,i.c)
      doc.setLineWidth(i.w)
      doc.line(12, 0, 12, 9)
      doc.line(0, 12, 9, 12)

      doc.line(712, 0, 712, 9)
      doc.line(715, 12, 724, 12)

      doc.line(712, 1015, 712, 1024)
      doc.line(715, 1012, 724, 1012)

      doc.line(0, 1012, 9, 1012)
      doc.line(12, 1015, 12, 1024)


    doc.save('poster.pdf')
    # doc.output('dataurlstring', 'Test.pdf')

  render = () ->
    renderer.render( scene, camera )
    appendChild()
    renderPDF()

  appendChild = () ->
    imgData = renderer.domElement.toDataURL()
    imgNode = document.createElement("img")
    imgNode.src = imgData
    document.body.appendChild(imgNode)

  render()
